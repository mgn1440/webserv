WebServer
{
public:
	WebServer(std::string confFile);
private:
	std::map<int clientSocket, Request> mRequestMap;
	std::map<int clientSocket, std::queue<Response> > mResponseMap;
}

// singleton pattern
ConfigHandler
{
public:
	static void MakeConfigHandler(std::string confFile);
	static ConfigHandler* GetConfigHandler();
	size_t* GetMaxSizes(int port, std::string serverName); // need to request parsing
	std::queue<Response> GetResponseOf(std::vector<struct Request> requests);
private:
	static ConfigHandler* configHandler;
	ConfigHandler(std::string confFile);
	std::map<std::pair<int port, std::string serverName>, Server> mServerMap;
	std::map<std::string format, std::string type> mTypesMap;
}

Server
{
public:
	Server(std::ifstream& ifs);
private:
	map<std::string uri, Location> location;
}

Location
{
public:
	Location(std::ifstream& ifs);
private:

}

Request
{
public:
	Request(int port);
	std::vector<struct Request> GetRequestsOf(std::string buf);
}

Response
{
public:
	Response(struct Response);
	bool IsCGI();
	std::string GetErrorPage(int errorCode);
	std::string GetResponse();
	void setCGIBody(const std::string& CGIBody); // CGI에서 받은 body를 저장
private:
	bool CGI;
	std::string body;

	int pipefd;
}

// Response 생성자
// Response 생성자에서는 Response를 생성할 때 CGI인지 아닌지를 판단한다.
// Response queue를 반환하면, kqueue에서 이벤트(EVFILT_READ(pipe), EVFILT_WRITE(Response), EVFILT_PROC(CGI))
